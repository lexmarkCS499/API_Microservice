name: Build, Push Docker Image, and Deploy to Minikube

on:
  push:
    branches:
      - main  # Run the workflow when code is pushed to the main branch

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v3

      # Step 2: Set up Docker Buildx (for cross-platform image building)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Step 3: Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # Step 4: Build the Docker image
      - name: Build Docker Image
        run: docker build -t lexmarkkubernetes/apiservice:${{ github.sha }} .

      # Step 5: Push the Docker image to Docker Hub
      - name: Push Docker Image
        run: docker push lexmarkkubernetes/apiservice:${{ github.sha }}

      # Step 6: Tag the image with a version
      - name: Tag Image with version
        run: |
          VERSION=v1.0.$(echo ${{ github.run_number }})
          docker tag lexmarkkubernetes/apiservice:${{ github.sha }} lexmarkkubernetes/apiservice:$VERSION
          docker push lexmarkkubernetes/apiservice:$VERSION

      # Tag Image with latest
      - name: Tag Image with latest
        run: |
          docker tag lexmarkkubernetes/apiservice:${{ github.sha }} lexmarkkubernetes/apiservice:latest
          docker push lexmarkkubernetes/apiservice:latest

      # Tag Image with dev
      - name: Tag Image with dev
        run: |
          docker tag lexmarkkubernetes/apiservice:${{ github.sha }} lexmarkkubernetes/apiservice:dev
          docker push lexmarkkubernetes/apiservice:dev

      # Step 7: Update Kubernetes manifest with the new Docker image tag
      - name: Update Kubernetes Manifest
        run: |
          sed -i "s|image: lexmarkkubernetes/apiservice:.*|image: lexmarkkubernetes/apiservice:${{ github.sha }}|g" manifests/deployment.yaml

      # Step 8: Commit and push the updated manifest
      - name: Commit and push changes if any
        env:
          GIT_AUTH_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          git config --global user.name "Kamal Ghimire"
          git config --global user.email "kamalghimire121@gmail.com"
          git remote set-url origin https://${{ secrets.PAT_TOKEN }}@github.com/lexmarkCS499/API_Microservice.git
          
          if ! git diff --quiet; then
            git commit -am "Update Docker image to lexmarkkubernetes/apiservice:dev"
            git push origin main
          else
            echo "No changes to commit"
          fi

  deploy:
    needs: build-and-deploy
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Download and Install ArgoCD CLI in Working Directory
        run: |
          curl -sSL -o ./argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x ./argocd

      - name: Sync ArgoCD Application
        env:
          ARGOCD_TOKEN: ${{ secrets.ARGOCD_TOKEN }}
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
        run: |
          if [ "${{ github.ref_name }}" == "dev" ]; then
            ./argocd app sync dev-apiservice --server $ARGOCD_SERVER --auth-token $ARGOCD_TOKEN --grpc-web --prune
          elif [ "${{ github.ref_name }}" == "staging" ]; then
            ./argocd app sync staging-apiservice --server $ARGOCD_SERVER --auth-token $ARGOCD_TOKEN --grpc-web --prune
          elif [ "${{ github.ref_name }}" == "prod" ]; then
            ./argocd app sync prod-apiservice --server $ARGOCD_SERVER --auth-token $ARGOCD_TOKEN --grpc-web --prune
          fi
